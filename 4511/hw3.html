<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Homework Three â€“ Goldfrank Faculty Web Site</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="../site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>
MathJax = {
  loader: {
    load: ['[tex]/boldsymbol']
  },
  tex: {
    tags: "all",
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    packages: {
      '[+]': ['boldsymbol']
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Goldfrank Faculty Web Site</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../advising.html"> 
<span class="menu-text">Advising</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../4511/index.html"> 
<span class="menu-text">AI Algorithms Course</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#files-you-will-edit" id="toc-files-you-will-edit" class="nav-link" data-scroll-target="#files-you-will-edit">Files you will edit</a></li>
  <li><a href="#files-you-might-want-to-look-at" id="toc-files-you-might-want-to-look-at" class="nav-link" data-scroll-target="#files-you-might-want-to-look-at">Files you might want to look at</a></li>
  </ul></li>
  <li><a href="#the-expr-class" id="toc-the-expr-class" class="nav-link" data-scroll-target="#the-expr-class">The Expr Class</a>
  <ul class="collapse">
  <li><a href="#a-note-on-conjoin-and-disjoin" id="toc-a-note-on-conjoin-and-disjoin" class="nav-link" data-scroll-target="#a-note-on-conjoin-and-disjoin">A note on <code>conjoin</code> and <code>disjoin</code></a></li>
  </ul></li>
  <li><a href="#prop-symbol-names-important" id="toc-prop-symbol-names-important" class="nav-link" data-scroll-target="#prop-symbol-names-important">Prop Symbol Names (Important!)</a>
  <ul class="collapse">
  <li><a href="#rules" id="toc-rules" class="nav-link" data-scroll-target="#rules">Rules</a></li>
  <li><a href="#pacphysics-symbols" id="toc-pacphysics-symbols" class="nav-link" data-scroll-target="#pacphysics-symbols">Pacphysics symbols</a></li>
  <li><a href="#sat-solver-setup" id="toc-sat-solver-setup" class="nav-link" data-scroll-target="#sat-solver-setup">SAT Solver Setup</a></li>
  </ul></li>
  <li><a href="#question-1-2-points-logic-warm-up" id="toc-question-1-2-points-logic-warm-up" class="nav-link" data-scroll-target="#question-1-2-points-logic-warm-up">Question 1 (2 points): Logic Warm-up</a></li>
  <li><a href="#question-2-2-points-logic-workout" id="toc-question-2-2-points-logic-workout" class="nav-link" data-scroll-target="#question-2-2-points-logic-workout">Question 2 (2 points): Logic Workout</a></li>
  <li><a href="#question-3-4-points-pacphysics-and-satisfiability" id="toc-question-3-4-points-pacphysics-and-satisfiability" class="nav-link" data-scroll-target="#question-3-4-points-pacphysics-and-satisfiability">Question 3 (4 points): Pacphysics and Satisfiability</a></li>
  <li><a href="#question-4-4-points-path-planning-with-logic" id="toc-question-4-4-points-path-planning-with-logic" class="nav-link" data-scroll-target="#question-4-4-points-path-planning-with-logic">Question 4 (4 points): Path Planning with Logic</a></li>
  <li><a href="#question-5-3-points-eating-all-the-food" id="toc-question-5-3-points-eating-all-the-food" class="nav-link" data-scroll-target="#question-5-3-points-eating-all-the-food">Question 5 (3 points): Eating All the Food</a></li>
  <li><a href="#helper-functions-for-the-rest-of-the-project" id="toc-helper-functions-for-the-rest-of-the-project" class="nav-link" data-scroll-target="#helper-functions-for-the-rest-of-the-project">Helper Functions For The Rest Of The Project</a>
  <ul class="collapse">
  <li><a href="#add-pacphysics-action-and-percept-information-to-kb" id="toc-add-pacphysics-action-and-percept-information-to-kb" class="nav-link" data-scroll-target="#add-pacphysics-action-and-percept-information-to-kb">Add pacphysics, action, and percept information to KB</a></li>
  <li><a href="#find-possible-pacman-locations-with-updated-kb" id="toc-find-possible-pacman-locations-with-updated-kb" class="nav-link" data-scroll-target="#find-possible-pacman-locations-with-updated-kb">Find possible pacman locations with updated KB</a></li>
  <li><a href="#find-provable-wall-locations-with-updated-kb" id="toc-find-provable-wall-locations-with-updated-kb" class="nav-link" data-scroll-target="#find-provable-wall-locations-with-updated-kb">Find provable wall locations with updated KB</a></li>
  </ul></li>
  <li><a href="#question-6-4-points-localization" id="toc-question-6-4-points-localization" class="nav-link" data-scroll-target="#question-6-4-points-localization">Question 6 (4 points): Localization</a></li>
  <li><a href="#question-7-3-points-mapping" id="toc-question-7-3-points-mapping" class="nav-link" data-scroll-target="#question-7-3-points-mapping">Question 7 (3 points): Mapping</a></li>
  <li><a href="#question-8-4-points-slam" id="toc-question-8-4-points-slam" class="nav-link" data-scroll-target="#question-8-4-points-slam">Question 8 (4 points): SLAM</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Homework Three</h1>
<p class="subtitle lead">Logic</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In this project, you will use/write simple Python functions that generate logical sentences describing Pacman physics, aka pacphysics. Then you will use a SAT solver, pycosat, to solve the logical inference tasks associated with planning (generating action sequences to reach goal locations and eat all the dots), localization (finding oneself in a map, given a local sensor model), mapping (building the map from scratch), and SLAM (simultaneous localization and mapping).</p>
<p>As in previous programming assignments, this assignment includes an autograder for you to grade your answers on your machine. This can be run with the command:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Submitting
</div>
</div>
<div class="callout-body-container callout-body">
<p>The test cases you run at home are the same test cases that I will use. You can turn in your homework and unlimited number of times to the submission server, however <strong>the server will not autograde this assignment.</strong> If you pass the test cases locally, you will pass them when I run them.</p>
</div>
</div>
<p>The code for this project consists of several Python files, some of which you will need to read and understand in order to complete the assignment, and some of which you can ignore. You can download all the code and supporting files in <a href="logic.zip">logic dot zip</a>.</p>
<section id="files-you-will-edit" class="level3">
<h3 class="anchored" data-anchor-id="files-you-will-edit">Files you will edit</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<tbody>
<tr class="odd">
<td><code>logicPlan.py</code></td>
<td>Where you will put your code for the various logical agents.</td>
</tr>
</tbody>
</table>
</section>
<section id="files-you-might-want-to-look-at" class="level3">
<h3 class="anchored" data-anchor-id="files-you-might-want-to-look-at">Files you might want to look at</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<tbody>
<tr class="odd">
<td><code>logic.py</code></td>
<td>Propsitional logic code originally from https://code.google.com/p/aima-python/ with modifications for our project. There are several useful utility functions for working with logic in here.</td>
</tr>
<tr class="even">
<td><code>logicAgents.py</code></td>
<td>The file that defines in logical planning form the two specific problems that Pacman will encounter in this project.</td>
</tr>
<tr class="odd">
<td><code>pycosat_test.py</code></td>
<td>Quick test main function that checks that the pycosat module is installed correctly.</td>
</tr>
<tr class="even">
<td><code>game.py</code></td>
<td>The internal simulator code for the Pacman world. The only thing you might want to look at in here is the Grid class.</td>
</tr>
<tr class="odd">
<td><code>test_cases/</code></td>
<td>Directory containing the test cases for each question</td>
</tr>
</tbody>
</table>
<p><strong>Files to Edit and Submit:</strong> You will edit <code>logicPlan.py</code>. Submit it <strong>in an uncompressed tar</strong> to the submission server, just like the other homeworks. This assignment will be graded out of 100, with 104 points available: you can earn 4 pts of extra credit.</p>
<p><strong>Evaluation:</strong> Your code will be autograded for technical correctness. Please <em>do not</em> change the names of any provided functions or classes within the code, or you will wreak havoc on the autograder. However, the correctness of your implementation â€“ not the autograderâ€™s judgements â€“ will be the final judge of your score. If necessary, I will review and grade assignments individually to ensure that you receive due credit for your work.</p>
<p><strong>Academic Dishonesty:</strong> This assignment should be your own work, as outlined in the syllabus. Ask if you have questions. I do check, and I take this seriously.</p>
</section>
</section>
<section id="the-expr-class" class="level2">
<h2 class="anchored" data-anchor-id="the-expr-class">The Expr Class</h2>
<p>In the first part of this project, you will be working with the <code>Expr</code> class defined in <code>logic.py</code> to build propositional logic sentences. An <code>Expr</code> object is implemented as a tree with logical operators (<span class="math inline">\land</span>, <span class="math inline">\lor</span>, <span class="math inline">\neg</span>, <span class="math inline">\Rightarrow</span>, <span class="math inline">\iff</span>) at each node and with literals (A, B, C) at the leaves. Here is an example sentence and its representation:</p>
<p>(A <span class="math inline">\land</span> B) <span class="math inline">\iff</span> (<span class="math inline">\neg</span> C <span class="math inline">\lor</span> D)</p>
<div style="max-width: 65%; margin: auto">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="logic_tree.png" class="img-fluid figure-img"></p>
<figcaption>Example logic tree.</figcaption>
</figure>
</div>
</div>
<p>To instantiate a symbol named â€˜Aâ€™, call the constructor like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> Expr(<span class="st">'A'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>Expr</code> class allows you to use Python operators to build up these expressions. The following are the available Python operators and their meanings:</p>
<ul>
<li><code>~A</code>: <span class="math inline">\neg</span> A</li>
<li><code>A &amp; B</code>: A <span class="math inline">\land</span> B</li>
<li><code>A | B</code>: A <span class="math inline">\lor</span> B</li>
<li><code>A &gt;&gt; B</code>: A <span class="math inline">\Rightarrow</span> B</li>
<li><code>A % B</code>: A <span class="math inline">\iff</span> B</li>
</ul>
<p>So to build the expression A <span class="math inline">\land</span> B, you would type this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> Expr(<span class="st">'A'</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> Expr(<span class="st">'B'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>a_and_b <span class="op">=</span> A <span class="op">&amp;</span> B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>(Note that <code>A</code> to the left of the assignment operator in that example is just a Python variable name, i.e.&nbsp;<code>symbol1 = Expr('A')</code> would have worked just as well.)</p>
<section id="a-note-on-conjoin-and-disjoin" class="level3">
<h3 class="anchored" data-anchor-id="a-note-on-conjoin-and-disjoin">A note on <code>conjoin</code> and <code>disjoin</code></h3>
<p>One last important thing to note is that you must use <code>conjoin</code> and <code>disjoin</code> operators wherever possible. <code>conjoin</code> creates a chained <code>&amp;</code> (logical AND) expression, and <code>disjoin</code> creates a chained <code>|</code> (logical OR) expression. Letâ€™s say you wanted to check whether conditions A, B, C, D, and E are all true. The naive way to achieve this is writing <code>condition = A &amp; B &amp; C &amp; D &amp; E</code>, but this actually translates to <code>((((A &amp; B) &amp; C) &amp; D) &amp; E)</code>, which creates a very nested logic tree (see <code>(1)</code> in diagram below) and becomes a nightmare to debug. Instead, <code>conjoin</code> makes a flat tree (see <code>(2)</code> in diagram below).</p>
<div style="max-width: 85%; margin: auto">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="conjoin_diagram.png" class="img-fluid figure-img"></p>
<figcaption>Conoin/Disjoin Examples</figcaption>
</figure>
</div>
</div>
</section>
</section>
<section id="prop-symbol-names-important" class="level2">
<h2 class="anchored" data-anchor-id="prop-symbol-names-important">Prop Symbol Names (Important!)</h2>
<p>For the rest of the project, please use the following variable naming conventions:</p>
<section id="rules" class="level3">
<h3 class="anchored" data-anchor-id="rules">Rules</h3>
<ul>
<li>When we introduce variables, they must start with an upper-case character (including <code>Expr</code>).</li>
<li>Only these characters should appear in variable names: <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>_</code>, <code>^</code>, <code>[</code>, <code>]</code>.</li>
<li>Logical connective characters (<code>&amp;</code>, <code>|</code>) must not appear in variable names. So, <code>Expr('A &amp; B')</code> is illegal because it attempts to create a single constant symbol named <code>'A &amp; B'</code>. We would use <code>Expr('A') &amp; Expr('B')</code> to make a logical expression.</li>
</ul>
</section>
<section id="pacphysics-symbols" class="level3">
<h3 class="anchored" data-anchor-id="pacphysics-symbols">Pacphysics symbols</h3>
<ul>
<li><code>PropSymbolExpr(pacman_str, x, y, time=t)</code>: whether or not Pacman is at (x, y) at time t, writes <code>P[x,y]_t</code>.</li>
<li><code>PropSymbolExpr(wall_str, x, y)</code>: whether or not a wall is at (x, y), writes <code>WALL[x,y]</code>.</li>
<li><code>PropSymbolExpr(action, time=t)</code>: whether or not pacman takes action <code>action</code> at time t, where <code>action</code> is an element of <code>DIRECTIONS</code>, writes i.e.&nbsp;<code>North_t</code>.</li>
<li>In general, <code>PropSymbolExpr(str, a1, a2, a3, a4, time=a5)</code> creates the expression <code>str[a1,a2,a3,a4]_a5</code> where <code>str</code> is just a string.</li>
</ul>
<p>There is additional, more detailed documentation for the <code>Expr</code> class in <code>logic.py</code>.</p>
</section>
<section id="sat-solver-setup" class="level3">
<h3 class="anchored" data-anchor-id="sat-solver-setup">SAT Solver Setup</h3>
<p>A SAT (satisfiability) solver takes a logic expression which encodes the rules of the world and returns a model (true and false assignments to logic symbols) that satisfies that expression if such a model exists. To efficiently find a possible model from an expression, we take advantage of the <a href="https://pypi.python.org/pypi/pycosat">pycosat</a> module, which is a Python wrapper around the <a href="http://fmv.jku.at/picosat/">picoSAT library</a>.</p>
<p>You can install using</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pycosat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If your Python executable is <code>python3</code>, you may need</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip3</span> install pycosat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you use conda:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> install pycosat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you use <code>mamba</code>, <code>poetry</code>, <code>rye</code>, <code>uv</code>, etc., use the syntax for your package manager.</p>
<p>After unzipping the project code and changing to the project code directory, run:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> pycosat_test.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This should output:</p>
<pre><code>[1, -2, -3, -4, 5]</code></pre>
<p>Please let me know if you have issues with this setup. This is critical to completing the project, and I donâ€™t want you to spend your time fighting with this installation process.</p>
</section>
</section>
<section id="question-1-2-points-logic-warm-up" class="level2">
<h2 class="anchored" data-anchor-id="question-1-2-points-logic-warm-up">Question 1 (2 points): Logic Warm-up</h2>
<p>This question will give you practice working with the <code>Expr</code> data type used in the project to represent propositional logic sentences. You will implement the following functions in <code>logicPlan.py</code>:</p>
<ul>
<li><code>sentence1()</code>: Create one <code>Expr</code> instance that represents the proposition that the following three sentences are true. Do not do any logical simplification, just put them in a list in this order, and return the list conjoined. Each element of your list should correspond to each of the three sentences.</li>
</ul>
<p>A <span class="math inline">\lor</span> B</p>
<p><span class="math inline">\neg</span> A <span class="math inline">\iff</span> (<span class="math inline">\neg</span> B <span class="math inline">\lor</span> C)</p>
<p><span class="math inline">\neg</span> A <span class="math inline">\lor</span> <span class="math inline">\neg</span> B <span class="math inline">\lor</span> C</p>
<ul>
<li><code>sentence2()</code>: Create one <code>Expr</code> instance that represents the proposition that the following four sentences are true. Again, do not do any logical simplification, just put them in a list in this order, and return the list conjoined.</li>
</ul>
<p>C <span class="math inline">\iff</span> (B <span class="math inline">\lor</span> D)</p>
<p>A <span class="math inline">\Rightarrow</span> (<span class="math inline">\neg</span> B <span class="math inline">\land</span> <span class="math inline">\neg</span> D)</p>
<p><span class="math inline">\neg</span> (B <span class="math inline">\land</span> <span class="math inline">\neg</span> C) <span class="math inline">\Rightarrow</span> A</p>
<p><span class="math inline">\neg</span> D <span class="math inline">\Rightarrow</span> C</p>
<ul>
<li><code>sentence3()</code>: Using the <code>PropSymbolExpr</code> constructor, create symbols named <code>PacmanAlive_0</code>, <code>PacmanAlive_1</code>, <code>PacmanBorn_0</code>, and <code>PacmanKilled_0</code>. Hint: recall that <code>PropSymbolExpr(str, a1, a2, a3, a4, time=a5)</code> creates the expression <code>str[a1,a2,a3,a4]_a5</code> where <code>str</code> is a string; you should make some strings for this problem. Then, create one <code>Expr</code> instance which encodes the following three <em>English</em> sentences as propositional logic in this order without any simplification:</li>
</ul>
<ol type="1">
<li>Pacman is alive at time 1 if and only if he was alive at time 0 and he was not killed at time 0 or he was not alive at time 0 and he was born at time 0.</li>
<li>At time 0, Pacman cannot both be alive and be born.</li>
<li>Pacman is born at time 0.</li>
</ol>
<ul>
<li><code>findModelCheck()</code>:</li>
</ul>
<ol type="1">
<li>Look at how the <code>findModel(sentence)</code> method works: it uses <code>to_cnf</code> to convert the input sentence into Conjunctive Normal Form (the form required by the SAT solver), and passes it to the SAT solver to find a satisfying assignment to the symbols in <code>sentence</code>, i.e., a model. A model is a dictionary of the symbols in your expression and a corresponding assignment of True or False. Test your <code>sentence1()</code>, <code>sentence2()</code>, and <code>sentence3()</code> with <code>findModel</code> by opening an interactive session in Python and running <code>from logicPlan import *</code> and <code>findModel(sentence1())</code> and similar queries for the other two. Do they match what you thought?</li>
<li>Based on the above, fill in <code>findModelCheck</code> so that it returns something that looks the exact same as <code>findModel(Expr('a'))</code> in a Python interactive session would if lower-cased letters were allowed. You should not use <code>findModel</code> or <code>Expr</code>, simply directly recreate the output. For instance, if the output was <code>[(MyVariable, True)]</code>, something close to the solution would be <code>return [("MyVariable", True)]</code>.</li>
</ol>
<ul>
<li><code>entails(premise, conclusion)</code>: Return True if and only if the <code>premise</code> entails the <code>conclusion</code>. Hint: <code>findModel</code> is helpful here; think about what must be unsatisfiable in order for the entails to be True, and what it means for something to be unstatisfiable.</li>
<li><code>plTrueInverse(assignments, inverse_statement)</code>: Returns True if and only if the (not inverse_statement) is True given assignments.</li>
</ul>
<p>Before you continue, try instantiating a small sentence, e.g.&nbsp;A <span class="math inline">\land</span> B <span class="math inline">\Rightarrow</span> C, and call <code>to_cnf</code> on it. Inspect the output and make sure you understand it (refer to Russell &amp; Norvig, Section 7.5.2, for details on the algorithm <code>to_cnf</code> implements).</p>
<p>To test and debug your code run:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="question-2-2-points-logic-workout" class="level2">
<h2 class="anchored" data-anchor-id="question-2-2-points-logic-workout">Question 2 (2 points): Logic Workout</h2>
<p>Implement the following three functions in <code>logicPlan.py</code>:</p>
<ul>
<li><code>atLeastOne(literals)</code>: Return a single expression (Expr) in CNF that is true only if at least one expression in the input list is true. Each input expression will be a literal.</li>
<li><code>atMostOne(literals)</code>: Return a single expression (Expr) in CNF that is true only if at most one expression in the input list is true. Each input expression will be a literal. HINT: Use <code>itertools.combinations</code>. If you have nnn literals, and at most one is true, your resulting CNF expression should be a conjunction of (n2)(n2)n \choose 2 clauses.</li>
<li><code>exactlyOne(literals)</code>: Return a single expression (Expr) in CNF that is true only if exactly one expression in the input list is true. Each input expression will be a literal. If you decide to call your previously implemented <code>atLeastOne</code> and <code>atMostOne</code>, call <code>atLeastOne</code> first to pass our autograder for q3.</li>
</ul>
<p>Each of these methods takes a list of <code>Expr</code> literals and returns a single <code>Expr</code> expression that represents the appropriate logical relationship between the expressions in the input list. An additional requirement is that the returned Expr must be in CNF (conjunctive normal form). <strong>You may NOT use the <code>to_cnf</code> function in your method implementations (or any of the helper functions <code>logic.eliminate_implications</code>, <code>logic.move_not_inwards</code>, and <code>logic.distribute_and_over_or</code>).</strong></p>
<p>Donâ€™t run to_cnf on your knowledge base when implementing your planning agents in later questions. This is because <code>to_cnf</code> makes your logical expression much longer sometimes, so you want to minimize this effect, and findModel does this already. In later questions, reuse your implementations for <code>atLeastOne(.)</code>, <code>atMostOne(.)</code>, and <code>exactlyOne(.)</code> instead of re-engineering these functions (to avoid accidentally making an unreasonably slow non-CNF-based implementation) from scratch.</p>
<p>You may utilize the <code>logic.pl_true</code> function to test the output of your expressions. <code>pl_true</code> takes an expression and a model and returns True if and only if the expression is true given the model.</p>
<p>To test and debug your code run:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="question-3-4-points-pacphysics-and-satisfiability" class="level2">
<h2 class="anchored" data-anchor-id="question-3-4-points-pacphysics-and-satisfiability">Question 3 (4 points): Pacphysics and Satisfiability</h2>
<p>In this question, you will implement the basic pacphysics logical expressions, as well as learn how to prove where pacman is and isnâ€™t by building an appropriate knowledge base (KB) of logical expressions.</p>
<p>Implement the following functions in <code>logicPlan.py</code>:</p>
<ul>
<li><p><code>pacmanSuccessorAxiomSingle</code>: This generates an expression defining the sufficient and necessary conditions for Pacman to be at (x, y) at t:</p></li>
<li><p>Read the construction of possible_causes provided.</p></li>
<li><p>You need to fill out the return statement, which will be an <code>Expr</code>. Make sure to use <code>disjoin</code> and <code>conjoin</code> where appropriate. Looking at <code>SLAMSuccessorAxiomSingle</code> may be helpful, although note that the rules there are more complicated than in this function. The simpler side of the biconditional should be on the left for autograder purposes.</p></li>
<li><p><code>pacphysicsAxioms</code>: Here, you will generate a bunch of physics axioms. For timestep t:</p></li>
<li><p>Arguments:</p></li>
<li><p>Required: <code>t</code> = time, <code>all_coords</code> and <code>non_outer_wall_coords</code> are lists of (x, y) tuples.</p></li>
<li><p>Possibly-None: You will be using these to call functions, not much logic is required.</p>
<ul>
<li><code>walls_grid</code> is only passed through to <code>successorAxioms</code> and describes (known) walls.</li>
<li><code>sensorModel(t: int, non_outer_wall_coords) -&gt; Expr</code> returns a single <code>Expr</code> describing observation rules; you can take a look at <code>sensorAxioms</code> and <code>SLAMSensorAxioms</code> to see examples of this.</li>
<li><code>successorAxioms(t: int, walls_grid, non_outer_wall_coords) -&gt; Expr</code> describes transition rules, e.g.&nbsp;how previous locations and actions of Pacman affect the current location; we have seen this in the functions in the previous bullet point. ONLY CALL THIS IF NECESSARY (when there are grid walls, and t!= 0)</li>
</ul></li>
<li><p>Algorithm:</p></li>
<li><p>For all (x, y) in <code>all_coords</code>, append the following implication (if-then form): if a wall is at (x, y), then Pacman is not at (x, y) at t.</p></li>
<li><p>Pacman is at exactly one of the <code>non_outer_wall_coords</code> at timestep t.</p></li>
<li><p>Pacman takes exactly one of the four actions in <code>DIRECTIONS</code> at timestep t.</p></li>
<li><p>Sensors: append the result of <code>sensorAxioms</code>. All callers except for <code>checkLocationSatisfiability</code> make use of this; how to handle the case where we donâ€™t want any sensor axioms added is up to you.</p></li>
<li><p>Transitions: append the result of <code>successorAxioms</code>. All callers will use this.</p></li>
<li><p>Add each of the sentences above to <code>pacphysics_sentences</code>. As you can see in the return statement, these will be conjoined and returned.</p></li>
<li><p>Function passing syntax:</p></li>
<li><p>Let <code>def myFunction(x, y, t): return PropSymbolExpr('hello', x, y, time=t)</code> be a function we want to use.</p></li>
<li><p>Let <code>def myCaller(func: Callable): ...</code> be the caller that wants to use a function.</p></li>
<li><p>We can pass the function in: <code>myCaller(myFunction)</code> (note that <code>myFunction</code> is not called with <code>()</code> after it).</p></li>
<li><p>We can use <code>myFunction</code> by having inside <code>myCaller</code> this: <code>useful_return = func(0, 1, q)</code>.</p></li>
<li><p><code>checkLocationSatisfiability</code>: Given a transition (<code>x0_y0, action0, x1_y1</code>), <code>action1</code>, and a <code>problem</code>, you will write a function that will return a tuple of two models <code>(model1, model2)</code>.</p>
<ul>
<li><p>In <code>model1</code>, Pacman is at (x1, y1) at time t = 1 given <code>x0_y0, action0, action1</code>, proving that itâ€™s possible that Pacman there. Notably, if <code>model1</code> is <code>False</code>, we know Pacman is guaranteed to NOT be there.</p></li>
<li><p>In <code>model2</code>, Pacman is NOT at (x1, y1) at time t = 1 given <code>x0_y0, action0, action1</code>, proving that itâ€™s possible that Pacman is not there. Notably, if <code>model2</code> is <code>False</code>, we know Pacman is guaranteed to be there.</p></li>
<li><p><code>action1</code> has no effect on determining whether the Pacman is at the location; itâ€™s there just to match your solution to the autograder solution.</p></li>
<li><p>To implement this problem, you will need to add the following expressions to your KB:</p></li>
<li><p>Add to KB: <code>pacphysics_axioms(...)</code> with the appropriate timesteps. There is no <code>sensorModel</code> because we know everything about the world. Where needed, use <code>allLegalSuccessorAxioms</code> for transitions since this is for regular Pacman transition rules.</p></li>
<li><p>Add to KB: Pacmanâ€™s current location (x0, y0)</p></li>
<li><p>Add to KB: Pacman takes <code>action0</code></p></li>
<li><p>Add to KB: Pacman takes <code>action1</code></p></li>
<li><p>Query the SAT solver with <code>findModel</code> for two models described earlier. The queries should be different; for a reminder on how to make queries see <code>entails</code>.</p></li>
</ul></li>
</ul>
<p>Reminder: the variable for whether Pacman is at (x, y) at time t is <code>PropSymbolExpr(pacman_str, x, y, time=t)</code>, wall exists at (x, y) is <code>PropSymbolExpr(wall_str, x, y)</code>, and action is taken at t is <code>PropSymbolExpr(action, time=t)</code>.</p>
<p>To test and debug your code run:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="question-4-4-points-path-planning-with-logic" class="level2">
<h2 class="anchored" data-anchor-id="question-4-4-points-path-planning-with-logic">Question 4 (4 points): Path Planning with Logic</h2>
<p>Pacman is trying to find the end of the maze (the goal position). Implement the following method using propositional logic to plan Pacmanâ€™s sequence of actions leading him to the goal:</p>
<p>Disclaimer: the methods from now on will be decently slow. This is because a SAT solver is very general and simply crunches logic, unlike our previous algorithms that employ a specific human-created algorithm to specific type of problem. Of note, Pycosatâ€™s main algorithm is in C, which is generally a much much faster language to execute than Python, and itâ€™s still this slow.</p>
<ul>
<li><code>positionLogicPlan(problem)</code>: Given an instance of <code>logicPlan.PlanningProblem</code>, returns a sequence of action strings for the Pacman agent to execute.</li>
</ul>
<p>You will not be implementing a search algorithm, but creating expressions that represent pacphysics for all possible positions at each time step. This means that at each time step, you should be adding general rules for all possible locations on the grid, where the rules do not assume anything about Pacmanâ€™s current position.</p>
<p>You will need to code up the following sentences for your knowledge base, in the following pseudocode form:</p>
<ul>
<li><p>Add to KB: Initial knowledge: Pacmanâ€™s initial location at timestep 0</p></li>
<li><p>for t in range(50). (Autograder will not test on layouts requiring <span class="math inline">\geq</span> 50 timesteps.)</p></li>
<li><p>Print time step; this is to see that the code is running and how far it is.</p></li>
<li><p>Add to KB: Initial knowledge: Pacman can only be at <code>exactlyOne</code> of the locations in <code>non_wall_coords</code> at timestep t. This is similar to <code>pacphysicsAxioms</code>, but donâ€™t use that method since we are using <code>non_wall_coors</code> when generating the list of possible locations in the first place (and <code>walls_grid</code> later).</p></li>
<li><p>Is there a satisfying assignment for the variables given the knowledge base so far? Use <code>findModel</code> and pass in the Goal Assertion and <code>KB</code>.</p></li>
<li><p>If there is, return a sequence of actions from start to goal using <code>extractActionSequence</code>.</p></li>
<li><p>Here, Goal Assertion is the expression asserting that Pacman is at the goal at timestep t.</p></li>
<li><p>Add to KB: Pacman takes exactly one action per timestep.</p></li>
<li><p>Add to KB: Transition Model sentences: call <code>pacmanSuccessorAxiomSingle(...)</code> for all possible pacman positions in <code>non_wall_coords</code>.</p></li>
</ul>
<p>Test your code on smaller mazes using:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> pacman.py <span class="at">-l</span> maze2x2 <span class="at">-p</span> LogicAgent <span class="at">-a</span> fn=plp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> pacman.py <span class="at">-l</span> tinyMaze <span class="at">-p</span> LogicAgent <span class="at">-a</span> fn=plp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To test and debug your code run:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that with the way we have Pacmanâ€™s grid laid out, the leftmost, bottommost space occupiable by Pacman (assuming there isnâ€™t a wall there) is <strong>(1, 1)</strong>, as shown below (<strong>not (0, 0)</strong>).</p>
<div style="max-width: 25%; margin: auto">
<p><img src="grid.png" class="img-fluid"></p>
</div>
<p>Summary of Pacphysics used in Q3 and Q4:</p>
<ul>
<li>For all x, y, t: if there is a wall at (x, y), then pacman is not at (x, y) at t.</li>
<li>For each t: Pacman is at exactly on of the locations described by all possible (x, y). Can be optimized with knowledge of outer or all walls, follow spec for each function.</li>
<li>For each t: Pacman takes exactly on of the possible actions.</li>
<li>For each t (except for t = ??): Transition model: Pacman is at (x, y) at t if and only if he was at (join with or: (x - dx, y - dy) at t-1 and took action (dx, dy) at t-1).</li>
</ul>
<p>Note that the above always hold true regardless of any specific game, actions, etc. To the above always-true/ axiom rules, we add information consistent with what we know.</p>
<p>Debugging hints:</p>
<ul>
<li>If youâ€™re finding a length-0 or a length-1 solution: is it enough to simply have axioms for where Pacman is at a given time? Whatâ€™s to prevent him from also being in other places?</li>
<li>As a sanity check, verify that if Pacman is at <code>(1, 1)</code> at time 0 and at <code>(4, 4)</code> at time 6, he was never at <code>(5, 5)</code> at any time in between.</li>
<li>If your solution is taking more than a couple minutes to finish running, you may want to revisit implementation of <code>exactlyOne</code> and <code>atMostOne</code>, and ensure that youâ€™re using as few clauses as possible.</li>
</ul>
</section>
<section id="question-5-3-points-eating-all-the-food" class="level2">
<h2 class="anchored" data-anchor-id="question-5-3-points-eating-all-the-food">Question 5 (3 points): Eating All the Food</h2>
<p>Pacman is trying to eat all of the food on the board. Implement the following method using propositional logic to plan Pacmanâ€™s sequence of actions leading him to the goal.</p>
<ul>
<li><code>foodLogicPlan(problem)</code>: Given an instance of <code>logicPlan.PlanningProblem</code>, returns a sequence of action strings for the Pacman agent to execute.</li>
</ul>
<p>This question has the same general format as question 4; you may copy your code from there as a starting point. The notes and hints from question 4 apply to this question as well. You are responsible for implementing whichever successor state axioms are necessary that were not implemented in previous questions.</p>
<p>What you will change from the previous question:</p>
<ul>
<li>Initialize Food[x,y]_t variables with the code <code>PropSymbolExpr(food_str, x, y, time=t)</code>, where each variable is true if and only if there is a food at (x, y) at time t.</li>
<li>Change the goal assertion: Your goal assertion sentence must be true if and only if all of the food have been eaten. This happens when all Food[x,y]_t are false.</li>
<li>Add a food successor axiom: What is the relation between Food[x,y]_t+1 and Food[x,y]_t and Pacman[x,y]_t? The food successor axiom should only involve these three variables, for any given (x, y) and t. Think about what the transition model for the food variables looks like, and add these sentences to your knowledge base at each timestep.</li>
</ul>
<p>Test your code using:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> pacman.py <span class="at">-l</span> testSearch <span class="at">-p</span> LogicAgent <span class="at">-a</span> fn=flp,prob=FoodPlanningProblem</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will not test your code on any layouts that require more than 50 time steps.</p>
<p>To test and debug your code run:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q5</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="helper-functions-for-the-rest-of-the-project" class="level2">
<h2 class="anchored" data-anchor-id="helper-functions-for-the-rest-of-the-project">Helper Functions For The Rest Of The Project</h2>
<p>For the remaining questions, we will rely on the following helper functions, which will be referenced by the pseudocode for localization, mapping, and SLAM.</p>
<section id="add-pacphysics-action-and-percept-information-to-kb" class="level3">
<h3 class="anchored" data-anchor-id="add-pacphysics-action-and-percept-information-to-kb">Add pacphysics, action, and percept information to KB</h3>
<ul>
<li>Add to KB: <code>pacphysics_axioms(...)</code>, which you wrote in q3. Use <code>sensorAxioms</code> and <code>allLegalSuccessorAxioms</code> for localization and mapping, and <code>SLAMSensorAxioms</code> and <code>SLAMSuccessorAxioms</code> for SLAM only.</li>
<li>Add to KB: Pacman takes action prescribed by <code>agent.actions[t]</code></li>
<li>Get the percepts by calling <code>agent.getPercepts()</code> and pass the percepts to <code>fourBitPerceptRules(...)</code> for localization and mapping, or <code>numAdjWallsPerceptRules(...)</code> for SLAM. Add the resulting percept_rules to <code>KB</code>.</li>
</ul>
</section>
<section id="find-possible-pacman-locations-with-updated-kb" class="level3">
<h3 class="anchored" data-anchor-id="find-possible-pacman-locations-with-updated-kb">Find possible pacman locations with updated KB</h3>
<ul>
<li><p><code>possible_locations = []</code></p></li>
<li><p>Iterate over <code>non_outer_wall_coords</code>.</p></li>
<li><p>Can we prove whether Pacman is at (x, y)? Can we prove whether Pacman is not at (x, y)? Use <code>entails</code> and the <code>KB</code>.</p></li>
<li><p>If there exists a satisfying assignment where Pacman is at (x, y) at time t, add (x, y) to <code>possible_locations</code>.</p></li>
<li><p>Add to KB: (x, y) locations where Pacman is provably at, at time t.</p></li>
<li><p>Add to KB: (x, y) locations where Pacman is provably not at, at time t.</p></li>
<li><p>Hint: check if the results of entails contradict each other (i.e.&nbsp;KB entails A and entails <span class="math inline">\neg</span> A). If they do, print feedback to help debugging.</p></li>
</ul>
</section>
<section id="find-provable-wall-locations-with-updated-kb" class="level3">
<h3 class="anchored" data-anchor-id="find-provable-wall-locations-with-updated-kb">Find provable wall locations with updated KB</h3>
<ul>
<li><p>Iterate over <code>non_outer_wall_coords</code>.</p></li>
<li><p>Can we prove whether a wall is at (x, y)? Can we prove whether a wall is not at (x, y)? Use <code>entails</code> and the <code>KB</code>.</p></li>
<li><p>Add to KB and update <code>known_map</code>: (x, y) locations where there is provably a wall.</p></li>
<li><p>Add to KB and update <code>known_map</code>: (x, y) locations where there is provably not a wall.</p></li>
<li><p>Hint: check if the results of entails contradict each other (i.e.&nbsp;KB entails A and entails <span class="math inline">\neg</span> A). If they do, print feedback to help debugging.</p></li>
</ul>
<p>Observation: we add known Pacman locations and walls to KB so that we donâ€™t have to redo the work of finding this on later timesteps; this is technically redundant information since we proved it using the KB in the first place.</p>
</section>
</section>
<section id="question-6-4-points-localization" class="level2">
<h2 class="anchored" data-anchor-id="question-6-4-points-localization">Question 6 (4 points): Localization</h2>
<p>The Pacman starts with a known map, but unknown starting location. It has a 4-bit sensor that returns whether there is a wall in its NSEW directions. (For example, 1001 means there is a wall to pacmanâ€™s North and West directions, and these 4-bits are represented using a list with 4 booleans.) By keeping track of these sensor readings and the action it took at each timestep, Pacman is able to pinpoint its location. You will code up the sentences that help Pacman determine the possible locations it can be at each timestep by implementing:</p>
<ul>
<li><code>localization(problem, agent)</code>: Given an instance of <code>logicPlan.LocalizationProblem</code> and an instance of <code>logicAgents.LocalizationLogicAgent</code>, repeatedly yields for timesteps t between 0 and <code>agent.num_steps-1</code> a list of possible locations (x_i, y_i) at t: [(x_0_0, y_0_0), (x_1_0, y_1_0), â€¦]. Note that you donâ€™t need to worry about how generators work as that line is already written for you.</li>
</ul>
<p>For Pacman to make use of sensor information during localization, you will use two methods already implemented for you: <code>sensorAxioms</code> â€“ i.e.&nbsp;</p>
<p>Blocked[Direction]_t <span class="math inline">\iff</span> [(P[x_i, y_j]_t <span class="math inline">\land</span> WALL[x_i+dx, y_j+dy]) <span class="math inline">\lor</span> (P[x_iâ€™, y_jâ€™]_t <span class="math inline">\land</span> WALL[x_iâ€™+dx, y_jâ€™+dy]) â€¦ ]</p>
<p>â€“ and <code>fourBitPerceptRules</code>, which translate the percepts at time t into logic sentences.</p>
<p>Please implement the function according to our pseudocode:</p>
<ul>
<li><p>Add to <code>KB</code>: where the walls are (<code>walls_list</code>) and arenâ€™t (not in <code>walls_list</code>).</p></li>
<li><p>for t in <code>range(agent.num_timesteps)</code>:</p></li>
<li><p>Add pacphysics, action, and percept information to KB.</p></li>
<li><p>Find possible pacman locations with updated KB.</p></li>
<li><p>Call <code>agent.moveToNextState(action_t)</code> on the current agent action at timestep t.</p></li>
<li><p><code>yield</code> the possible locations.</p></li>
</ul>
<p>Note on display: the yellow Pacman is where he is at the time thatâ€™s currently being calculated, so possible locations and known walls and free spaces are from the previous timestep.</p>
<p>To test and debug your code run:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q6</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="question-7-3-points-mapping" class="level2">
<h2 class="anchored" data-anchor-id="question-7-3-points-mapping">Question 7 (3 points): Mapping</h2>
<p>Pacman now knows his starting location, but does not know where the walls are (other than the fact that the border of outer coordinates are walls). Similar to localization, it has a 4-bit sensor that returns whether there is a wall in its NSEW directions. You will code up the sentences that help Pacman determine the location of the walls by implementing:</p>
<ul>
<li><p><code>mapping(problem, agent)</code>: Given an instance of <code>logicPlan.MappingProblem</code> and an instance of <code>logicAgents.MappingLogicAgent</code>, repeatedly yields for timesteps t between 0 and <code>agent.num_steps-1</code> knowledge about the map [[1, 1, 1, 1], [1, -1, 0, 0], â€¦ ] at t. Note that you donâ€™t need to worry about how generators work as that line is already written for you.</p></li>
<li><p><code>known_map</code>:</p></li>
<li><p><code>known_map</code> is a 2D-array (list of lists) of size (problem.getWidth()+2, problem.getHeight()+2), because we have walls around the problem.</p></li>
<li><p>Each entry of <code>known_map</code> is 1 if (x, y) is guaranteed to be a wall at timestep t, 0 if (x, y) is guaranteed to not be a wall, and -1 if (x, y) is still ambiguous at timestep t.</p></li>
<li><p>Ambiguity results when one cannot prove that (x, y) is a wall and one cannot prove that (x, y) is not a wall.</p></li>
</ul>
<p>Please implement the function according to our pseudocode:</p>
<ul>
<li><p>Get initial location <code>(pac_x_0, pac_y_0)</code> of Pacman, and add this to <code>KB</code>. Also add whether there is a wall at that location.</p></li>
<li><p>for t in <code>range(agent.num_timesteps)</code>:</p></li>
<li><p>Add pacphysics, action, and percept information to KB.</p></li>
<li><p>Find provable wall locations with updated KB.</p></li>
<li><p>Call <code>agent.moveToNextState(action_t)</code> on the current agent action at timestep t.</p></li>
<li><p><code>yield known_map</code></p></li>
</ul>
<p>To test and debug your code run:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q7</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="question-8-4-points-slam" class="level2">
<h2 class="anchored" data-anchor-id="question-8-4-points-slam">Question 8 (4 points): SLAM</h2>
<p>Sometimes Pacman is just really lost and in the dark at the same time. In SLAM (Simultaneous Localization and Mapping), Pacman knows his initial coordinates, but does not know where the walls are. In SLAM, Pacman may inadvertently take illegal actions (for example, going North when there is a wall blocking that action), which will add to the uncertainty of Pacmanâ€™s location over time. Additionally, in our setup of SLAM, Pacman no longer has a 4 bit sensor that tells us whether there is a wall in the four directions, but only has a 3-bit sensor that reveals the number of walls he is adjacent to. (This is sort of like wifi signal-strength bars; 000 = not adjacent to any wall; 100 = adjacent to exactly 1 wall; 110 = adjacent to exactly 2 walls; 111 = adjacent to exactly 3 walls. These 3 bits are represented by a list of 3 booleans.) Thus, instead of using <code>sensorAxioms</code> and <code>fourBitPerceptRules</code>, you will use <code>SLAMSensorAxioms</code> and <code>numAdjWallsPerceptRules</code>. You will code up the sentences that help Pacman determine (1) his possible locations at each timestep, and (2) the location of the walls, by implementing:</p>
<ul>
<li><code>slam(problem, agent)</code>: Given an instance of <code>logicPlan.SLAMProblem</code> and <code>logicAgents.SLAMLogicAgent</code>, repeatedly yields a tuple of two items:
<ul>
<li><code>known_map</code> at t (of the same format as in question 6 (mapping))</li>
<li>list of possible pacman locations at t (of the same format as in question 5 (localization))</li>
</ul></li>
</ul>
<p>To pass the autograder, please implement the function according to our pseudocode:</p>
<ul>
<li><p>Get initial location <code>(pac_x_0, pac_y_0)</code> of Pacman, and add this to <code>KB</code>. Update <code>known_map</code> accordingly and add the appropriate expression to KB.</p></li>
<li><p>for t in <code>range(agent.num_timesteps)</code>:</p></li>
<li><p>Add pacphysics, action, and percept information to KB. Use <code>SLAMSensorAxioms</code>, <code>SLAMSuccessorAxioms</code>, and <code>numAdjWallsPerceptRules</code>.</p></li>
<li><p>Find provable wall locations with updated KB. Make sure to add this to the KB before the next step.</p></li>
<li><p>Find possible pacman locations with updated KB.</p></li>
<li><p>Call <code>agent.moveToNextState(action_t)</code> on the current agent action at timestep t.</p></li>
<li><p><code>yield known_map, possible_locations</code></p></li>
</ul>
<p>To test and debug your code run (note: this is slow, my solution takes several minutes to run to completion on an M1 Macintosh Book Professional):</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q8</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
    <script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.algTitle || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        titlePrefix = el.dataset.algTitle;
        titleIndex = ""
        titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
      });
    })(document);
    </script>
  




</body></html>