<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Goldfrank Faculty Web Site - Homework Four</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="../../site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>
MathJax = {
  loader: {
    load: ['[tex]/boldsymbol']
  },
  tex: {
    tags: "all",
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    packages: {
      '[+]': ['boldsymbol']
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Goldfrank Faculty Web Site</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../advising.html"> 
<span class="menu-text">Advising</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../YOLO_8Apr.pdf"> 
<span class="menu-text">YOLO</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../4511/index.html"> 
<span class="menu-text">AI Algorithms Course</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#ghostbusters" id="toc-ghostbusters" class="nav-link active" data-scroll-target="#ghostbusters">Ghostbusters</a>
  <ul class="collapse">
  <li><a href="#provided-code-bayesian-networks" id="toc-provided-code-bayesian-networks" class="nav-link" data-scroll-target="#provided-code-bayesian-networks">Provided Code: Bayesian Networks</a></li>
  </ul></li>
  <li><a href="#q1-2-pts-bayesnet-structure" id="toc-q1-2-pts-bayesnet-structure" class="nav-link" data-scroll-target="#q1-2-pts-bayesnet-structure">Q1 (2 pts) BayesNet Structure</a></li>
  <li><a href="#q2-3-pts-join-factors" id="toc-q2-3-pts-join-factors" class="nav-link" data-scroll-target="#q2-3-pts-join-factors">Q2 (3 pts) Join Factors</a></li>
  <li><a href="#q3-3-pts-eliminate-factors" id="toc-q3-3-pts-eliminate-factors" class="nav-link" data-scroll-target="#q3-3-pts-eliminate-factors">Q3 (3 pts) Eliminate Factors</a></li>
  <li><a href="#q4-2-pts-variable-elimination" id="toc-q4-2-pts-variable-elimination" class="nav-link" data-scroll-target="#q4-2-pts-variable-elimination">Q4 (2 pts) Variable Elimination</a></li>
  <li><a href="#q5-1-pt" id="toc-q5-1-pt" class="nav-link" data-scroll-target="#q5-1-pt">Q5 (1 pt)</a></li>
  <li><a href="#q6-2-pts-exact-inference-observation" id="toc-q6-2-pts-exact-inference-observation" class="nav-link" data-scroll-target="#q6-2-pts-exact-inference-observation">Q6 (2 pts) Exact Inference Observation</a></li>
  <li><a href="#q7-2-pts-exact-inference-with-time-elapse" id="toc-q7-2-pts-exact-inference-with-time-elapse" class="nav-link" data-scroll-target="#q7-2-pts-exact-inference-with-time-elapse">Q7 (2 pts) Exact Inference with Time Elapse</a></li>
  <li><a href="#q8-1-pt-exact-inference-full-test" id="toc-q8-1-pt-exact-inference-full-test" class="nav-link" data-scroll-target="#q8-1-pt-exact-inference-full-test">Q8 (1 pt) Exact Inference Full Test</a></li>
  <li><a href="#q9-1-pts-approximate-inference-initialization-and-beliefs" id="toc-q9-1-pts-approximate-inference-initialization-and-beliefs" class="nav-link" data-scroll-target="#q9-1-pts-approximate-inference-initialization-and-beliefs">Q9 (1 pts) Approximate Inference (Initialization and Beliefs)</a></li>
  <li><a href="#q10-2-pts-particle-filter---observation" id="toc-q10-2-pts-particle-filter---observation" class="nav-link" data-scroll-target="#q10-2-pts-particle-filter---observation">Q10 (2 pts) Particle Filter - Observation</a></li>
  <li><a href="#q11-2-pts-particle-filter" id="toc-q11-2-pts-particle-filter" class="nav-link" data-scroll-target="#q11-2-pts-particle-filter">Q11 (2 pts) Particle Filter 💪</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Homework Four</h1>
<p class="subtitle lead">Tracking</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>This assignment is individual effort; adhere to the syllabus collaboration policy and ask me if you have any questions.</em></p>
<section id="ghostbusters" class="level1">
<h1>Ghostbusters</h1>
<p>We have turned the tables. Now, Pacman will hunt the ghosts.</p>
<p>There is one caveat: the ghosts are invisible, and Pacman can only listen. Your sensor is a noisy reading of Manhattan distance to each ghost. To succeed, hunt and eat all ghosts on the map.</p>
<p>Download the starter code in <a href="tracking.zip">tracking dot zip</a> and try the game yourself:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> busters.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The blocks of color indicate where the each ghost could possibly be, given the noisy distance readings provided to Pacman. The noisy distances at the bottom of the display are always non-negative, and always within 7 of the true distance. The probability of a distance reading decreases exponentially with its difference from the true distance.</p>
</div>
</div>
</div>
<p>Your primary task in this project is to implement inference to track the ghosts. For the keyboard-based game above, a crude form of inference was implemented for you by default: <em>all squares in which a ghost could possibly be are shaded by the color of the ghost.</em></p>
<p>Throughout the rest of this project, you will implement algorithms for performing both exact and approximate inference using Bayes Nets.</p>
<p><strong>Submission:</strong> You will edit <code>bustersAgents.py</code>, <code>inference.py</code>, and <code>factorOperations.py</code>. When complete, submit a single uncompressed tar of these files to the submit server. This assignment will <strong>not</strong> be graded immediately by the server, but I will run the same test cases that you have: if you complete the assignment according to the instructions, the grade you get from autograding locally is the grade you’ll get on the assignment.</p>
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Autograder Details
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>While watching and debugging your code with the autograder, it will be helpful to have some understanding of what the autograder is doing. There are 2 types of tests in this project, as differentiated by their .test files found in the subdirectories of the test_cases folder. For tests of class DoubleInferenceAgentTest, you will see visualizations of the inference distributions generated by your code, but all Pacman actions will be pre-selected according to the actions of the staff implementation. This is necessary to allow comparision of your distributions with the staff’s distributions. The second type of test is GameScoreTest, in which your BustersAgent will actually select actions for Pacman and you will watch your Pacman play and win games.</p>
<p>For this project, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code>--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>
</div>
</div>
</div>
<section id="provided-code-bayesian-networks" class="level3">
<h3 class="anchored" data-anchor-id="provided-code-bayesian-networks">Provided Code: Bayesian Networks</h3>
<p>First, take a look at <code>bayesNet.py</code> to see the classes you’ll be working with – BayesNet and Factor. You can also run this file to see an example BayesNet and associated Factors: python bayesNet.py.</p>
<p>You should look at the <code>printStarterBayesNet</code> function – there are helpful comments that can make your life much easier later on.</p>
<p>The Bayes Net created in this function is shown below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="starterBayesNet.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:45.0%"></p>
</figure>
</div>
<p>A summary of the terminology is given below:</p>
<ul>
<li><p><strong>Bayes Net:</strong> This is a representation of a probabilistic model as a directed acyclic graph and a set of conditional probability tables, one for each variable, as shown in lecture. The Traffic Bayes Net above is an example.</p></li>
<li><p><strong>Factor:</strong> This stores a table of probabilities, although the sum of the entries in the table is not necessarily 1.</p>
<ul>
<li>A factor is of the general form $f(X_1,…,X_m,y_1,…,y_n ∣ Z_1,…,Z_p,w_1,…,w_q) $.</li>
<li>Lower case variables have already been assigned.</li>
<li>For each possible assignment of values to the <span class="math inline">\(X_i​\)</span> and <span class="math inline">\(Z_j\)</span>​ variables, the factor stores a single number.</li>
<li>The <span class="math inline">\(Z_j\)</span>​ and <span class="math inline">\(w_k\)</span>​ variables are conditioned while the <span class="math inline">\(X_i\)</span>​ and <span class="math inline">\(y_l\)</span>​ variables are unconditioned.</li>
</ul></li>
<li><p><strong>Conditional Probability Table (CPT):</strong> This is a factor satisfying two properties:</p>
<ul>
<li>Its entries must sum to 1 for each assignment of the conditional variables.</li>
<li>There is exactly one unconditioned variable.</li>
<li>The Traffic Bayes Net stores the following CPTs:
<ul>
<li><span class="math inline">\(P(Raining)\)</span></li>
<li><span class="math inline">\(P(Ballgame)\)</span></li>
<li><span class="math inline">\(P(Traffic | Ballgame, Raining)\)</span></li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="q1-2-pts-bayesnet-structure" class="level1 page-columns page-full">
<h1>Q1 (2 pts) BayesNet Structure</h1>
<p>Implement the <code>constructBayesNet</code> function in <code>inference.py.</code></p>
<p>It constructs an empty Bayes Net with the structure described below.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;A Bayes Net is incomplete without the actual probabilities, but factors are defined and assigned by starter code separately; you don’t need to worry about it. If you are curious, you can take a look at an example of how it works in <code>printStarterBayesNet</code> in <code>bayesNet.py</code>. Reading this function can also be helpful for doing this question.</p></div></div><p>The simplified ghost hunting world is generated according to the following Bayes net:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="bayesNet.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:55.0%"></p>
</figure>
</div>
<p>Don’t worry if this looks complicated! We’ll take it step by step. As described in the code for <code>constructBayesNet</code>, we build the empty structure by listing all of the variables, their values, and the edges between them. This figure shows the variables and the edges, but what about their domains?</p>
<ul>
<li>Add variables and edges based on the diagram.</li>
<li>Pacman and the two ghosts can be anywhere in the grid (we ignore walls for this).
<ul>
<li>Add all possible position tuples for these.</li>
</ul></li>
<li>Observations here are non-negative, equal to Manhattan distances of Pacman to ghosts <span class="math inline">\(\pm\)</span> noise.</li>
</ul>
<p>To test and debug your code, run</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="q2-3-pts-join-factors" class="level1">
<h1>Q2 (3 pts) Join Factors</h1>
<p>Implement the <code>joinFactors</code> function in <code>factorOperations.py</code>. It takes in a list of Factors and returns a new Factor whose probability entries are the product of the corresponding rows of the input Factors.</p>
<p><code>joinFactors</code> can be used as the product rule/law of total probability:</p>
<ul>
<li>For example, if we have a factor of the form <span class="math inline">\(P(X∣Y)\)</span> and another factor of the form <span class="math inline">\(P(Y)\)</span>, then joining these factors will yield <span class="math inline">\(P(X,Y)\)</span>.</li>
<li><code>joinFactors</code> allows us to incorporate probabilities for conditioned variables (in this case, <span class="math inline">\(Y\)</span>).</li>
<li>However, you should not assume that <code>joinFactors</code> is called on probability tables.
<ul>
<li>It is possible to call joinFactors on Factors whose rows do not sum to 1.</li>
</ul></li>
</ul>
<p>Grading: To test and debug your code, run</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It may be useful to run specific tests during debugging, to see only one set of factors print out. For example, to only run the first test, run:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-t</span> test_cases/q2/1-product-rule</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hints
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Your <code>joinFactors</code> function should return a new <code>Factor</code>.</p>
<p>Here are some examples of what <code>joinFactors</code> can do:</p>
<ul>
<li><span class="math inline">\(\texttt{joinFactors}(P(X∣Y),P(Y)) \rightarrow P(X,Y)\)</span></li>
<li><span class="math inline">\(\texttt{joinFactors}(P(V,W∣X,Y,Z),P(X,Y∣Z)) \rightarrow P(V,W,X,Y∣Z)\)</span></li>
<li><span class="math inline">\(\texttt{joinFactors}(P(X∣Y,Z),P(Y))=P(X,Y∣Z)\)</span></li>
<li><span class="math inline">\(\texttt{joinFactors}(P(V∣W),P(X∣Y),P(Z))=P(V,X,Z∣W,Y)\)</span></li>
</ul>
<p>For a general <code>joinFactors</code> operation, which variables are unconditioned in the returned <code>Factor</code>? Which variables are conditioned?</p>
<ul>
<li><code>Factor</code> objects store a <code>variableDomainsDict</code>, which maps each variable to a list of values that it can take on (its domain).</li>
<li>A <code>Factor</code> gets its <code>variableDomainsDict</code> from the <code>BayesNet</code> from which it was instantiated.</li>
<li>As a result, it contains all the variables of the <code>BayesNet</code>, not only the unconditioned and conditioned variables used in the <code>Factor</code>.</li>
<li>For this problem, you may assume that all the input <code>Factor</code> objects have come from the same <code>BayesNet</code>, and so their <code>variableDomainsDicts</code> are all the same.</li>
</ul>
</div>
</div>
</div>
</section>
<section id="q3-3-pts-eliminate-factors" class="level1">
<h1>Q3 (3 pts) Eliminate Factors</h1>
<p>Implement the <code>eliminate</code> function in <code>factorOperations.py</code>.</p>
<ul>
<li>It takes a <code>Factor</code> and a variable to eliminate and returns a new <code>Factor</code> that does not contain that variable.</li>
<li>This corresponds to summing all of the entries in the <code>Factor</code> which only differ in the value of the variable being eliminated.</li>
</ul>
<p>Grading: To test and debug your code, run</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It may be useful to run specific tests during debugging, to see only one set of factors print out. For example, to only run the first test, run:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-t</span> test_cases/q3/1-simple-eliminate</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hints
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Your eliminate should return a new <code>Factor</code>.</p>
<p><code>eliminate</code> can be used to marginalize variables from probability tables. For example:</p>
<ul>
<li><span class="math inline">\(\texttt{eliminate}(P(X,Y∣Z),Y)=P(X∣Z)\)</span></li>
<li><span class="math inline">\(\texttt{eliminate}(P(X,Y∣Z),X)=P(Y∣Z)\)</span></li>
</ul>
<p>For a general eliminate operation, which variables are unconditioned in the returned Factor? Which variables are conditioned?</p>
<p>Remember that <code>Factors</code> store the <code>variableDomainsDict</code> of the original <code>BayesNet</code>, and not only the unconditioned and conditioned variables that they use. As a result, the returned <code>Factor</code> should have the same <code>variableDomainsDict</code> as the input <code>Factor</code>.</p>
</div>
</div>
</div>
</section>
<section id="q4-2-pts-variable-elimination" class="level1">
<h1>Q4 (2 pts) Variable Elimination</h1>
<p>Implement the <code>inferenceByVariableElimination</code> function in <code>inference.py</code>. It answers a probabilistic query, which is represented using a <code>BayesNet</code>, a list of query variables, and the evidence.</p>
<p>Grading: To test and debug your code, run</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It may be useful to run specific tests during debugging, to see only one set of factors print out. For example, to only run the first test, run:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-t</span> test_cases/q4/1-disconnected-eliminate</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hints
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li><p>The algorithm should iterate over hidden variables in elimination order, performing joining over and eliminating that variable, until the only the query and evidence variables remain.</p></li>
<li><p>The sum of the probabilities in your output factor should sum to 1 (so that it is a true conditional probability, conditioned on the evidence).</p></li>
<li><p>Look at the <code>inferenceByEnumeration</code> function in <code>inference.py</code> for an example on how to use the desired functions.</p></li>
<li><p>Reminder: Inference by enumeration first joins over all the variables and then eliminates all the hidden variables.</p>
<ul>
<li>In contrast, variable elimination interleaves join and eliminate by iterating over all the hidden variables and perform a join and eliminate on a single hidden variable before moving on to the next hidden variable.</li>
</ul></li>
</ul>
<p>You will need to take care of the special case where a factor you have joined only has one unconditioned variable (the docstring specifies what to do in greater detail).</p>
</div>
</div>
</div>
</section>
<section id="q5-1-pt" class="level1">
<h1>Q5 (1 pt)</h1>
<p>Unfortunately, having time steps will grow our graph far too much for variable elimination to be viable. Instead, we will use the Forward Algorithm for HMM’s for exact inference, and Particle Filtering for even faster but approximate inference.</p>
<p>For the rest of the project, we will be using the <code>DiscreteDistribution</code> class defined in <code>inference.py</code> to model belief distributions and weight distributions.</p>
<ul>
<li>This class is an extension of the built-in Python dictionary class, where the keys are the different discrete elements of our distribution, and the corresponding values are proportional to the belief or weight that the distribution assigns that element.</li>
<li>This question asks you to fill in the missing parts of this class, which will be crucial for later questions (even though this question itself is worth no points).</li>
</ul>
<ol type="1">
<li><p>Fill in the <code>normalize</code> method, which normalizes the values in the distribution to sum to one, but keeps the proportions of the values the same. Use the <code>total</code> method to find the sum of the values in the distribution. For an empty distribution or a distribution where all of the values are zero, do nothing. Note that this method modifies the distribution directly, rather than returning a new distribution.</p></li>
<li><p>Fill in the <code>sample</code> method, which draws a sample from the distribution, where the probability that a key is sampled is proportional to its corresponding value. Assume that the distribution is not empty, and not all of the values are zero. Note that the distribution does not necessarily have to be normalized prior to calling this method. You may find Python’s built-in <code>random.random()</code> function useful for this question.</p></li>
<li><p>Implement the <code>getObservationProb</code> method in the <code>InferenceModule</code> base class in <code>inference.py</code>.</p>
<ul>
<li>This method takes in an observation (which is a noisy reading of the distance to the ghost), Pacman’s position, the ghost’s position, and the position of the ghost’s jail.</li>
<li>The method returns the probability of the noisy distance reading given Pacman’s position and the ghost’s position. In other words, we want to return <span class="math inline">\(P(noisyDistance∣pacmanPosition, ghostPosition)\)</span>.</li>
<li>The distance sensor has a probability distribution over distance readings given the true distance from Pacman to the ghost. This distribution is modeled by the function <code>busters.getObservationProbability(noisyDistance, trueDistance)</code>, which returns <span class="math inline">\(P(noisyDistance∣trueDistance)\)</span> and is provided for you. You should use this function to help you solve the problem, and use the provided <code>manhattanDistance</code> function to find the distance between Pacman’s location and the ghost’s location.</li>
<li>There is the special case of jail that we have to handle as well. Specifically, when we capture a ghost and send it to the jail location, our distance sensor deterministically returns <code>None</code>, and nothing else (observation = <code>None</code> if and only if ghost is in jail). One consequence of this is that if the ghost’s position is the jail position, then the observation is <code>None</code> with probability 1, and everything else with probability 0. Make sure you handle this special case in your implementation; we effectively have a different set of rules for whenever ghost is in jail, as well as whenever observation is <code>None</code>.</li>
</ul></li>
</ol>
<p>To test your code and run the autograder for this question:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q5</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="q6-2-pts-exact-inference-observation" class="level1">
<h1>Q6 (2 pts) Exact Inference Observation</h1>
<p>In this question, you will implement the <code>observeUpdate</code> method in the <code>ExactInference</code> class of <code>inference.py</code> to correctly update the agent’s belief distribution over ghost positions given an observation from Pacman’s sensors. You are implementing the online belief update for observing new evidence.</p>
<ul>
<li>The <code>observeUpdate</code> method should, for this problem, update the belief at every position on the map after receiving a sensor reading.</li>
<li>You should iterate your updates over the variable <code>self.allPositions</code> which includes all legal positions plus the special jail position.</li>
<li>Beliefs represent the probability that the ghost is at a particular location, and are stored as a <code>DiscreteDistribution</code> object in a field called <code>self.beliefs</code>, which you should update.</li>
</ul>
<p>Be sure you know what inference problem you are trying to solve. You should use the function <code>self.getObservationProb</code> that you wrote in the last question, which returns the probability of an observation given Pacman’s position, a potential ghost position, and the jail position.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tips
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li><p>You can obtain Pacman’s position using <code>gameState.getPacmanPosition()</code>, and the jail position using <code>self.getJailPosition()</code>.</p></li>
<li><p>In the Pacman display, high posterior beliefs are represented by bright colors, while low beliefs are represented by dim colors. You should start with a large cloud of belief that shrinks over time as more evidence accumulates. As you watch the test cases, be sure that you understand how the squares converge to their final coloring.</p></li>
<li><p>Your busters agents have a separate inference module for each ghost they are tracking. That’s why if you print an observation inside the observeUpdate function, you’ll only see a single number even though there may be multiple ghosts on the board.</p></li>
</ul>
</div>
</div>
</div>
<p>To run the autograder for this question and visualize the output:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q6</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q6 <span class="at">--no-graphics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="q7-2-pts-exact-inference-with-time-elapse" class="level1 page-columns page-full">
<h1>Q7 (2 pts) Exact Inference with Time Elapse</h1>
<p>In the previous question you implemented belief updates for Pacman based on his observations. Pacman’s observations are not his only source of knowledge about where a ghost may be. Pacman also has knowledge about the ways that a ghost may move; namely that the ghost can not move through a wall or more than one space in one time step. You have a model for the Ghost’s behavior.</p>
<p>To understand why this is useful to Pacman, consider the following scenario in which there is Pacman and one Ghost. Pacman receives many observations which indicate the ghost is very near, but then one which indicates the ghost is very far. The reading indicating the ghost is very far is likely to be the result of a buggy sensor. Pacman’s prior knowledge of how the ghost may move will decrease the impact of this reading since Pacman knows the ghost could not move so far in only one move.</p>
<p>In this question, you will implement the <code>elapseTime</code> method in <code>ExactInference</code>. The <code>elapseTime</code> step should, for this problem, update the belief at every position on the map after one time step elapsing. Your agent has access to the action distribution for the ghost through <code>self.getPositionDistribution</code>. In order to obtain the distribution over new positions for the ghost, given its previous position, use this line of code:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>newPosDist <span class="op">=</span> <span class="va">self</span>.getPositionDistribution(gameState, oldPos)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Where <code>oldPos</code> refers to the previous ghost position. <code>newPosDist</code> is a <code>DiscreteDistribution</code> object, where for each position <code>p</code> in <code>self.allPositions</code>, <code>newPosDist[p]</code> is the probability that the ghost is at position <code>p</code> at time <code>t + 1</code>, given that the ghost is at position <code>oldPos</code> at time <code>t</code>. Note that this call can be fairly expensive, so if your code is timing out, one thing to think about is whether or not you can reduce the number of calls to <code>self.getPositionDistribution</code>.</p>
<p>Since Pacman is not observing the ghost’s actions, these actions will not impact Pacman’s beliefs. Over time, Pacman’s beliefs will come to reflect places on the board where he believes ghosts are most likely to be given the geometry of the board and ghosts’ possible legal moves, which Pacman already knows.</p>
<p>For the tests in this question we will sometimes use a ghost with random movements and other times we will use the <code>GoSouthGhost</code>. This ghost tends to move south so over time, and without any observations, Pacman’s belief distribution should begin to focus around the bottom of the board. To see which ghost is used for each test case you can look in the <code>.test</code> files.</p>
<p>The below diagram shows what the Bayes Net/ Hidden Markov model for what is happening.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Still, you should rely on the above description for implementation because some parts are implemented for you, i.e.&nbsp;<code>getPositionDistribution</code> is abstracted to be <span class="math inline">\(P(G_{t+1}∣gameState,G{t})\)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Only one Ghost is shown– each ghost is independent, given the Pacman position.</p></div></div><div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="moreBayesNet.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
<p>To run the autograder for this question and visualize the output:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q7</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q7 <span class="at">--no-graphics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As you watch the autograder output, remember that lighter squares indicate that Pacman believes a ghost is more likely to occupy that location, and darker squares indicate a ghost is less likely to occupy that location. For which of the test cases do you notice differences emerging in the shading of the squares? Can you explain why some squares get lighter and some squares get darker?</p>
</section>
<section id="q8-1-pt-exact-inference-full-test" class="level1">
<h1>Q8 (1 pt) Exact Inference Full Test</h1>
<p>Now you will hunt the ghosts.</p>
<p>We will use your <code>observeUpdate</code> and <code>elapseTime</code> implementations together to keep an updated belief distribution, and your simple greedy agent will choose an action based on the latest distributions at each time step.</p>
<ul>
<li>In the simple greedy strategy, Pacman assumes that each ghost is in its most likely position according to his beliefs, then moves toward the closest ghost.</li>
<li>Up to this point, Pacman has moved by randomly selecting a valid action.</li>
</ul>
<p>Implement the <code>chooseAction</code> method in <code>GreedyBustersAgent</code> in <code>bustersAgents.py</code>. Your agent should first find the most likely position of each remaining ghost, then choose an action that minimizes the maze distance to the closest ghost.</p>
<p>To find the maze distance between any two positions <code>pos1</code> and <code>pos2</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.distancer.getDistance(pos1, pos2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To find the successor position of a position after an action:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>Actions.getSuccessor(position, action)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You are provided with <code>livingGhostPositionDistributions</code>, a list of <code>DiscreteDistribution</code> objects representing the position belief distributions for each of the ghosts that are still uncaptured.</p>
<p>If correctly implemented, your agent should win the game in q8/3-gameScoreTest with a score greater than 700 at least 8 out of 10 times. Note: the autograder will also check the correctness of your inference directly, but the outcome of games is a reasonable sanity check.</p>
<p>We can represent how our greedy agent works with the following modification to the previous diagram:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="evenMoreBayesNet.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
<p>To run the autograder for this question and visualize the output:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q8</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q8 <span class="at">--no-graphics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="q9-1-pts-approximate-inference-initialization-and-beliefs" class="level1">
<h1>Q9 (1 pts) Approximate Inference (Initialization and Beliefs)</h1>
<p>Approximate inference is very trendy among ghost hunters this season. For the next few questions, you will implement a particle filtering algorithm for tracking a single ghost.</p>
<p>First, implement the functions <code>initializeUniformly</code> and <code>getBeliefDistribution</code> in the <code>ParticleFilter</code> class in <code>inference.py</code>. A particle (sample) is a ghost position in this inference problem. Note that, for initialization, particles should be evenly (not randomly) distributed across legal positions in order to ensure a uniform prior. We recommend thinking about how the mod operator is useful for <code>initializeUniformly</code>.</p>
<p>Note that the variable you store your particles in must be a list. A list is simply a collection of unweighted variables (positions in this case). Storing your particles as any other data type, such as a dictionary, is incorrect and will produce errors. The <code>getBeliefDistribution</code> method then takes the list of particles and converts it into a <code>DiscreteDistribution</code> object.</p>
<p>To test your code and run the autograder for this question:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q9</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="q10-2-pts-particle-filter---observation" class="level1">
<h1>Q10 (2 pts) Particle Filter - Observation</h1>
<p>Next, we will implement the <code>observeUpdate</code> method in the <code>ParticleFilter</code> class in <code>inference.py</code>. This method constructs a weight distribution over <code>self.particles</code> where the weight of a particle is the probability of the observation given Pacman’s position and that particle location. Then, we resample from this weighted distribution to construct our new list of particles.</p>
<p>You should again use the function <code>self.getObservationProb</code> to find the probability of an observation given Pacman’s position, a potential ghost position, and the jail position.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hints
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li><p>The sample method of the <code>DiscreteDistribution</code> class will be useful.</p></li>
<li><p>You can obtain Pacman’s position using <code>gameState.getPacmanPosition()</code>, and the jail position using <code>self.getJailPosition()</code>.</p></li>
<li><p>There is one special case– degeneracy– that a correct implementation must handle. When all particles receive zero weight, the list of particles should be reinitialized by calling <code>initializeUniformly</code>.</p>
<ul>
<li>The <code>total</code> method of the <code>DiscreteDistribution</code> may be useful.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<p>To run the autograder for this question and visualize the output:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q10</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q10 <span class="at">--no-graphics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="q11-2-pts-particle-filter" class="level1">
<h1>Q11 (2 pts) Particle Filter 💪</h1>
<p>Implement the <code>elapseTime</code> method in the <code>ParticleFilter</code> class in <code>inference.py</code>. This function should construct a new list of particles that corresponds to each existing particle in <code>self.particles</code> advancing a time step, and then assign this new list back to <code>self.particles</code>. When complete, you should be able to track ghosts nearly as effectively as with exact inference.</p>
<p>Note that in this question, we will test both the <code>elapseTime</code> method in isolation, as well as the full implementation of the particle filter combining <code>elapseTime</code> and <code>observe</code>.</p>
<p>As in the <code>elapseTime</code> method of the <code>ExactInference</code> class, you should use:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="va">self</span>.getPositionDistribution(gameState, oldPos)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This line of code obtains the distribution over new positions for the ghost, given its previous position (<code>oldPos</code>). The sample method of the <code>DiscreteDistribution</code> class will also be useful.</p>
<p>To run the autograder for this question and visualize the output:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q11</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> autograder.py <span class="at">-q</span> q11 <span class="at">--no-graphics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that even with no graphics, this test may take several minutes to run.</p>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
    <script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.algTitle || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        titlePrefix = el.dataset.algTitle;
        titleIndex = ""
        titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
      });
    })(document);
    </script>
  




</body></html>